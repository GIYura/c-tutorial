### Этапы компиляции

- препроцессор;
- компилятор;
- ассемблер;
- компановщик.

#### Препроцессор

Код, прошедший обработку препроцессором, называется единицей трансляции (или единицей
компиляции). 

Единица трансляции — это отдельный логический блок кода на C, сгенерированный препроцессором и готовый к компиляции.

В gcc можно сохранить единицу трансляции:

```
gcc -E file.c
gcc -E file.c > out.i /* сохранить в файл out.i вывод препроцессора */
```
Препроцессор не имеет никакого представления о языке C и потому не в состоянии найти какие-либо синтаксические ошибки.

**Итог этого этапа:**

На вход поступает исходный файл, а на выходе получается соответствующая единица трансляции (файл с расширением **.i**).

#### Компилятор

На вход подается единица компиляции, полученная на предыдущем этапе (**file.i**), а на выходе получается 
соответствующий **ассемблерный код**.

В gcc можно сохранить ассемблерный код:

```
gcc -S file.c
```

**Итог этого этапа:**

Файл с тем же именем что и исходник, но с расширением **.s**.

#### Ассемблер

Цель — сгенерировать инструкции машинного уровня (или машинный код) на основе ассемблерного кода, 
созданного компилятором на предыдущем этапе. У каждой архитектуры есть свой ассемблер, 
который может преобразовать собственный ассемблерный код в машинные инструкции.

Файл с машинными инструкциями, который мы сгенерируем в этом подразделе,
называется объектным файлом.

В большинстве Unix-подобных операционных систем есть утилита под названием **as**, 
с помощью которой ассемблерный код можно превратить в переносимый объектный файл.

```
as file.s -o file.o

```
Можно объединить предыдущих 3 шага в один с помощью команды:

```
gcc -c file.c
```
**Итог этого этапа:**

Переносимый объектный файл с тем же именем, что и у исходника с расширением **.o**.

Переносимые объектные файлы не являются исполняемыми. Если конечным продуктом компиляции проекта должен быть
исполняемый файл, то нужно взять все (или по крайней мере некоторые) переносимые объектные файлы, 
уже сгенерированные, и скомпоновать их в единое целое.

#### Компоновщик

Компоновщик по умолчанию в Unix-подобных системах — **ld**. 
Использовать копоновщик напрямую не рекомендуется, место этого нужно использовать команду:

```
gcc [file.o ... file.o]
```

**Итог этого этапа:**

Испольняемый файл.

Сборка проекта состоит из компиляции исходников с последующей их компоновкой и, возможно, 
добавлением других библиотек. В результате получаются итоговые продукты.

**Примечание:** 
Утилиты **as** и **ld** не встроены в компилятор **gcc**.

**Примечание:**
Вначале компилятор анализирует единицу трансляции и переводит ее в переносимую структуру данных под названием 
«дерево абстрактного синтаксиса» (abstract syntax tree, AST); данная структура не имеет прямогоотношения к языку C. 
Затем на ее основе генерируется подходящий ассемблерный код для целевой архитектуры.

Чтобы сгенерировать **.dot** файлы:
```
gcc test.c -fdump-tree-all-graph
```

[Reference:](http://icps.u-strasbg.fr/~pop/gcc-ast.html)

**Примечание:** 
Каждая ОС поддерживает свой двоичный формат (формат объектных файлов) для хранения инструкций машинного уровня. 
Поэтому содержимое объектного файла определяется двумя факторами:
- архитектурой (аппаратным обеспечением);
- операционной системой. 
Эта комбинация называется **платформой**.
В Linux используется формат **ELF** (Executable and Linking Format — формат исполняемых и компонуемых файлов).

**Примечание:**
В проекте на **С** можно сгенерировать следующие продукты (артефакты):

- ряд испольянемых файлов (**.out**);
- статичекая библиотека (**.a**);
- динамическая библиотека / разделяемый объект (**.so**).

**Примечание:**
Утилита **nm** позволяет просмотреть символы в объектном файле:
```
nm file.o
```

Утилита **readelf** позволяет просмотреть таблицу символов:
```
readelf -s file.o
```

Утилита **objdump** позволяет просмотреть машинные инструкции:
```
objdump -d file.o
```

**Пример:** имееются файлы 1.h/.c 2.h/.c и test.c, который ключает оба .h файла.
В файле 1.h и 2.h иммеется функция foo() с одинаковой сигнатурой. В таком случае
при потытке компиляции будет ошибка компиляции и сообщение о множественном 
определении функции foo().

Имеются два .c файла с функцией foo(), но при этом сигнатура их разная.
Если скоипилировать один .c файл, но при этом использовать функцию с другой
сигнатурой, то компиляция пройдет без ошибок, но при этом программа будет
работать некорректно.

Вывод: в С нет возможности различать функции с учетом параметров.
Декорирование имен (name mangling) применяется в С++, т.к в нем есть поддержка 
перегрузки функций.










