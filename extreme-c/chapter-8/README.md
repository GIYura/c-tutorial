### СОДЕРДАНИЕ

```
- src-0 - пример восходящего приведения типов;
- src-1 - наследования (вариант 1);
- src-2 - наследования (вариант 2);
- src-3 - наследования gpio и led;
- src-4 - полиморфизм.
```

#### Наследование

Наследование также называют расширением, поскольку оно только добавляет новые 
атрибуты и операции в существующий объект или класс.
Бывают случаи, когда один объект должен иметь те же атрибуты, которые есть
в другом. Иными словами, новый объект — расширение существующего.

Наследование реализует отношение типа «быть».

Существует 2 типа приведения:

- upcasting - приведение структуры атрибутов потомка к типу структуры атрибутов
родителя. Каждый сотрудник (студент) - это человек.

- downcasting - приведение структуры атрибутов родителя к типу структуры атрибутов
потомка. Не каждый человек это сотрудник или студент.

![Inheritance](https://github.com/GIYura/c-tutorial/blob/main/extreme-c/chapter-8/inheritance.png)

**Примечание:**

Наследование можно реализовать двумя путями:

- дочерний класс имеет доступ к приватной реализации (определению) базового класса;
- дочерний класс мог обращаться только к публичному интерфейсу базового класса.

##### Первый подход к наследованию в CИ (src-1)

1. Создать интерфейсный файл родительского класса (person.h);
2. Создать приватную часть родительского класса (person-p.h). Эта часть будет подключаться по меере необходимости;
3. Создать интерфейсный файл производного класса (student.h);
4. Создать файл реализации функций производного клласса (student.c);

**Примечаение:**
Каждый студент имеет имя, фамилию и год рождения, поэтому нет неодходимости создавать отдельные функции для 
доступа к этой информации о студенте, вместо этого можно воспользоваться функциями родительского класса.

##### Второй подход к наследованию в CИ (src-2)

1. Создать интерфейсный файл родительского класса (person.h);
2. Создать интерфейсный файл производного (дочернего) класса (student.h), при этом в приватной реализации 
будет указатель на родительский класс + поведенчиские функции - это обертки для соответсвующих функций 
родительского класса;
3. Создать соответсвующие файла реализации (student.c / person.c).

**Примечание:**
Ниже перечислены основные сходства и различия двух подходов в наследовании:

- Оба подхода, по сути, демонстрируют отношение типа «композиция»;
- В первом подходе структурная переменная находится в структуре атрибутов
потомка. Здесь требуется доступ к приватной реализации родительского класса.
Но во втором подходе используется структурный указатель неполного типа,
принадлежащего структуре атрибутов родителя, поэтому теряется зависимость
от приватной реализации родительского класса;
- В первом подходе родительский и дочерний типы тесно связаны. Во втором
классы независимы друг от друга и все, что находится в родительской реализа-
ции, скрыто от потомка;
- В первом подходе может быть только один родитель. То есть это реализация
одиночного наследования в C. Во втором же подходе родителей может быть
сколько угодно; так выглядит концепция множественного наследования;
- В первом подходе структурная переменная родителя должна быть первым полем
структуры атрибутов дочернего класса. Во втором указатели на родительские
объекты могут находиться в любом месте структуры;
- В первом подходе у нас не было двух отдельных объектов. Родительский объект
был частью дочернего, и указатель на дочерний объект являлся также указате-
лем на родительский.
- В первом подходе мы могли использовать поведенческие функции родительского
класса. Во втором нам пришлось делать для них обертки в дочернем классе.

#### Полиморфизм

Полиморфизм — предоставление разного поведения с помощью одного
и того же публичного интерфейса (или набора поведенческих функций).

Для использования преимуществ этой разновидности полиморфизма нам следует 
применять первый подход к наследованию в C.

В первом подходе у дочернего класса был доступ к приватной реализации родительского 
класса.










