#### СОДЕРЖАНИЕ

```
src-0 - пример обработки сигналов;
src-1 - пример использования POSIX-каналов;
src-2 - пример использования очередец сообщений.
```

#### Методы межпроцессного взаимодействия

К ним относят:
- разделяемая память;
- файловая система (как на диске, так и в памяти);
- POSIX-сигналы;
- POSIX-каналы;
- очереди сообщений POSIX;
- сокеты домена Unix;
- интернет-сокеты (или сетевые сокеты).

Сериализация - процесс преообразования объекта в байтовую последовательность.

Десериализация - процесс преобразования байтовой последовательности в объект.

Эти процессы — неотъемлемая часть всех методов IPC.

#### POSIX-сигналы

В POSIX-системах процессы и потоки могут отправлять и принимать ряд заранее определенных сигналов, 
каждый из которых может быть отправлен процессом, потоком или даже самим ядром. Cигналы предназначены для 
уведомления процессов или потоков о событиях или ошибках.

[Список сигналов](http://www.man7.org/linux/man-pages/man7/signal.7.html)

**Примечание:**

Запуск процесса в фоновом режиме:

```
./executable &
```

Передача разных сигналов фоновому процессу:

```
kill [-signal] [PID]
```

#### POSIX-каналы

Unix поддерживает однонаправленные POSIX-каналы (pipes), которые можно использовать для обмена сообщениями между двумя процессами.
При создании POSIX-канала вы получаете два файловых дескриптора: один для записи в канал, а второй для чтения из него.

**Примечание:**

Функция **mkfifo** используется для создания именованного канала.

Неименованные каналы применяются для родительского и дочернего процессов.
Именованные каналы применяются для независимых процессов.

![pipe](https://github.com/GIYura/c-tutorial/blob/main/extreme-c/chapter-19/pipe.png)

#### Очереди сообщений POSIX

Очереди сообщений, размещенные в ядре, — часть стандарта POSIX.

[queue](https://users.pja.edu.pl/~jms/qnx/help/watcom/clibref/mq_overview.html)

POSIX-каналы и очереди сообщений имеют ограниченный размер буфера в ядре. Следовательно, запись в канал или очередь, из которой никто
не читает, может привести к блокировке любых операций записи. Иными словами, любой вызов функции **write** будет оставаться заблокированным, 
пока потребитель не прочитает сообщение из очереди или байты из канала.

