#### СОДЕРЖАНИЕ

```
src-0 - пример устранения гонки данных с использованием POSIX-мьютексов;
src-1 - пример использования условных переменных POSIX;
src-2 - пример использования POSIX барьеров;
src-3 - пример использования двоичного семафора;
src-4 - пример использования семафора общего вида;
src-5 - пример использования кучи в качестве стека процесса;
src-6 - пример чтения переменной, выделенной в области стека другого потока;
src-7 - пример использования кучи.

**ЗАМЕЧАНИЕ:**
Для сборки примеров с барьерами необходимо использовать опцию gcc *-std=gnu99*
```

#### Мьютекс

Мьютекс — это семафор, который позволяет заходить на критический
участок только одному потоку за раз. В целом семафоры допускают нахождение
на критическом участке нескольких потоков.
Мьютексы также называют двоичными семафорами, поскольку они
являются разновидностью семафора с двумя возможными состояниями.

#### Условные переменные

Условную переменную нужно использовать только на критических участках, защищенных сопутствующим мьютексом.

**Примечание:** Следующее относится к коду в примере src-1.
Поток, который должен вывести A, пытается заблокировать мьютекс, используя указатель 
на объект разделяемого состояния.
Получив блокировки, данный поток выводит A, устанавливает флаг *done* и вызывает функцию *pthread_cond_signal()*, 
чтобы уведомить другой поток, который в это время может ждать условную переменную.

С другой стороны, если второй поток станет активным до того, как первый успеет вывести A,
то сам попытается получить блокировку мьютекса и в случае успеха проверит флаг *done*. 
Если флаг равен *false*, то это означает, что первый поток еще не зашел на критический участок
(в противном случае был бы равен *true*). Следовательно, второй поток подождет условную переменную и немедленно
освободит процессор, вызвав функцию *pthread_cond_wait()*.

Стоит обратить внимание на то, что во время ожидания условной переменной связанный с ней мьютекс освобождается 
и другой поток может продолжить работу. Вдобавок при активации и выходе из состояния ожидания необходимо снова 
получить мьютекс.

**Примечание:**
Функцию *pthread_cond_signal()* можно использовать для уведомления только единственного потока. Если нужно уведомить 
все потоки, которые ждут условную переменную, то для этого предусмотрена функция *pthread_cond_broadcast()*. 

#### POSIX-барьеры

Барьеры предназначены для синхронизации потоков, они имитируют контрольную точку, при достижении которой все
потоки должны остановиться и подождать, пока к ним не присоединятся остальные.

Объект барьера можно реализовать с помощью мьютекса и условной переменной. На самом деле POSIX-совместимые ОС 
не предоставляют такого механизма, как барьер, в своих интерфейсах системных вызовов, и большинство реализаций
основаны на мьютексах и условных переменных.

**Примечание:**

Использование барьеров делает код менее переносимым.

POSIX-барьеры обеспечивают видимость памяти. Подобно операциям блокировки и разблокировки, ожидание барьеров гарантирует, 
что все закэшированные версии одной и той же переменной синхронизируются между разными потоками непосредственно 
перед выходом из барьера.

#### POSIX-семафоры

В большинстве случаев мьютексов (или двоичных семафоров) достаточно для синхронизации разных потоков, 
обращающихся к разделяемому ресурсу. Дело в том, что для последовательного выполнения операций чтения и записи на критическом
участке должен находиться только **один** поток. Это называется взаимным исключением (mutual exclusion — отсюда и название «мьютекс»).
Но иногда может возникнуть необходимость в том, чтобы сразу несколько потоков могло работать с разделяемым ресурсом на критическом участке. 
В таких случаях следует использовать семафоры общего вида.

#### Двоичные семафоры

У каждого объекта семафора есть целочисленное значение. Если оно больше нуля и поток, который ожидает семафор, 
вызывает функцию *sem_wait()*, то значение уменьшается на 1, а потоку разрешается зайти на критический участок. 
Если оно равно нулю, то поток должен подождать, пока оно снова не станет положительным. Каждый раз, когда поток выходит 
с критического участка, вызывая функцию *sem_post()*, значение семафора увеличивается на 1. 
Следовательно, если с самого начала сделать его равным 1, то мы в конечном счете получим двоичный семафор (он же мьютекс).

#### Семафоры общего вида

Семафoр — примитив синхронизации работы процессов и потоков, в основе которого лежит счётчик, над которым можно производить 
две атомарные операции: 
- увеличение значения на единицу;
- уменьшение значения на единицу. 
при этом операция уменьшения для нулевого значения счётчика является блокирующейся. Служит для построения более сложных 
механизмов синхронизации и используется для синхронизации параллельно работающих задач, для защиты передачи данных через 
разделяемую память, для защиты критических секций, а также для управления доступом к аппаратному обеспечению.

**Примечание:**

С помощью команд, приведенных ниже можно получить информацию о текущем состоянии средств межпроцессного взаимодействия 
(inter-process communication, IPC):
- ipcs;
- ipcs -s - отображение информации об активных массивах семафоров;
- ipcs -m - просмотр информации об активных сегментах разделяемой памяти;
- ipcs -l - отображает лимиты разделяемой памяти, семафоров и сообщений;
- ipcs -m -c - отображает пользователя и группу владельца и создателя ресурса;
- ipcs -u - отображает сводку об использовании всех средств IPC;

При остановке сервисов семафоры и сегменты разделяемой памяти должны также удаляться. Если они не удаляются, 
то это можно сделать с помощью команды *ipcrm*, передав идентификатор IPC-объекта.
- ipcs -a
- ipcrm -s < sem id>

#### Сегмент стека

У каждого потока есть собственный сегмент стека, который должен быть доступен только ему. 
Стек потока — часть общего стека процесса-владельца, в котором по умолчанию должны выделяться сегменты стека для всех потоков. 
Но стек может быть выделен и в куче.
Поскольку все потоки внутри одного процесса могут читать и изменять его сегмент стека, они фактически имеют доступ к стекам друг друга. 
Но не должны пользоваться этим доступом. 
**Стоит отметить:** работа со стеками других потоков считается опасным поведением, так как переменные, определенные на вершине
стека, могут быть уничтожены в любой момент, особенно при завершении потока или возвращении функции.

Вот почему мы пытаемся исходить из того, что каждый сегмент стека доступен только его потоку-владельцу, но не другим потокам. 
Таким образом, локальные переменные (объявленные на вершине стека) считаются приватными ресурсами потока и другие потоки не должны 
к ним обращаться.

В однопоточных приложениях есть всего один, главный поток. Поэтому мы используем его сегмент стека так, словно это стек процесса. 
Причина в том, что в однопоточной программе между главным потоком и самим процессом нет никакого разделения. 
Но в многопоточных программах все иначе. У каждого потока есть свой стек, который отличается от стеков других потоков.

При создании нового потока в стеке процесса выделяется блок памяти. Если программист самостоятельно не указал его размер,
то будет использовано значение по умолчанию, которое зависит от платформы и варьируется от одной архитектуры к другой. 
В POSIX-совместимой системе можно использовать команду **ulimit -s**, чтобы узнать размер стека по умолчанию.

По умолчанию размер стека = 8 Мбайт.

#### Сегмент кучи

Куча может использоваться для хранения состояний, которые должны разделяться между разными потоками.
Когда дело доходит до выделения кучи, управление памятью превращается в настоящий кошмар. Причиной тому факт, что выделяемые 
ресурсы в конечном счете должен освободить один из активных потоков, иначе можно столкнуться с утечками памяти.

Применительно к конкурентным средам чередования могут легко привести к появлению висячих указателей, в результате чего возникают сбои. 
Важнейшая цель синхронизации состоит в упорядочении выполнения таким образом, чтобы висячие указатели не могли появиться, 
и достичь этого непросто.

