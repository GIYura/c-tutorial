/*
Внутри функции ThreadBody_1() сохраняем адрес локальной переменной в разделяемый указатель. 
Эта переменная принадлежит первому потоку и выделена на вершине его стека.
С этого момента по завершении первого потока разделяемый указатель станет
висячим, и любое его разыменование, скорее всего, проведет к сбою, логической
ошибке или в лучшем случае к неочевидным проблемам с памятью. Это происходит
в некоторых вариантах чередований, и в итоге, запустив программу несколько раз,
время от времени можно наблюдать сбои.

ВАЖНО: если один поток хочет использовать переменную, выделенную в стеке другого потока,
то следует реализовать подходящие методы синхронизации. Поскольку время жизни переменной в стеке привязано к ее области
видимости, синхронизация должна быть направлена на то, чтобы сохранять эту
область видимости активной, пока поток не закончит работать с переменной.
*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

int* shared_int;

void* ThreadBody_1(void* context)
{
    int local_var = 100;
    shared_int = &local_var;
    /* Ждем, пока другой поток не выведет разделяемое целое значение */
    usleep(10);
    return NULL;
}

void* ThreadBody_2(void* context)
{
    printf("%d\n", *shared_int);
    return NULL;
}

int main(int argc, char* argv[])
{
    shared_int = NULL;
    pthread_t m_thread1;
    pthread_t m_thread2;

    pthread_create(&m_thread1, NULL, ThreadBody_1, NULL);
    pthread_create(&m_thread2, NULL, ThreadBody_2, NULL);

    pthread_join(m_thread1, NULL);
    pthread_join(m_thread2, NULL);

    return 0;
}

