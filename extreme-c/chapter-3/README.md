#### СОДЕРЖАНИЕ

```
src-0 - пример создания и использования статических и динамических библиотек.
```

#### В этом разделе рассматривается:

- двоичный интерфейс приложений (ABI - Application Binary Interface);
- форматы объектных файлов;
- переносимые объектные файлы;
- исполняемые объектные файлы;
- статические библиотеки;
- динамические библиотеки.

**Примечание:**

ABI обычно содержит следующую информацию:

- набор инструкций целевой архитектуры, включая инструкции процессора,
структуры памяти, порядок следования байтов, регистры и т. д.;
- существующие типы данных, их размеры и правила выравнивания;
- соглашение о вызове функций, включая такие подробности, как структура стекового фрейма 
и порядок размещения аргументов в стеке;
- механизм системных вызовов в Unix-подобных ОС;
- используемые форматы объектных файлов, включая переносимые, исполняемые
и разделяемые;
- если речь идет об объектных файлах, сгенерированных компилятором C++, то
в состав ABI также входит метод декорирования имен и структура виртуальной
таблицы.

API обеспечивает совместимость двух программных компонентов с точки зрения
их функционального взаимодействия, то ABI гарантирует, что две программы
и их соответствующие объектные файлы совместимы на уровне машинных инструкций.

В Unix-подобных операционных системах, таких как Linux и BSD, самым распространенным 
стандартом ABI является System V.

**Примечание:**

В различных системах используются различные форматы объектных файлов:

- ELF применяется в Linux и многих других Unix-подобных ОС.
- Mach-O используется в системах OS X (macOS и iOS).
- PE применяется в Microsoft Windows.

**Примечание:**

Переносимые объектные файла содержат относительные адреса, готовые для перемещения.
На этапе компоновки адреса становятся абсолютными.

**Примечание:**

Сегмен **INTERP**, который на самом деле ссылается на секцию .interp, используется
загрузчиком для запуска и выполнения исполняемого файла.

#### Создание статической библиотеки 

Выполняется в несколько этапов:

- получение переносимых объектных файлов:
```
gcc -c file.c -o file.o
```
- объединение полученных объектных файлов в статическую библтотеку:
```
ar crs libName.a [file.o ... file.o]
```
- компиляция приложения, которое использует статическую библиотеку:
```
gcc -c main.c -o main.o
```
- компоновка со статичекой библиотекой:
```
gcc main.o -L/path-to-libName -lname -lm -o main.out
```

**Примечаение:**

-L/path-to-libName - сообщает компилятору где искать библиотеку.
По умолчанию компоновщик ищет библиотечные файлы в традиционных каталогах:

- /usr/lib;
- /usr/local/lib.

Параметр **-lname** говорит компилятору gcc, что ему нужно искать файл **libname.a** или **libname.so.**

Параметр **-lm** сообщает компилятору gcc, что нужно искать еще одну библиотеку с именем **libm.a** или **libm.so**.

Для создания статической библиотеки используется архиватор **ar.**
В системах семейства Unix применительно к статическим библиотекам действует
общепринятое соглашение об именовании. Имя файла должно начинаться с **lib**
и иметь расширение **.a.**
```
ar crs libMath.a [file.o .. file.o]
```
rcs = replace, create, sort.

```
ar t libName.a - позволяет просмотреть содержимое архива.
```

#### Создание динамической библиотеки 

Выполняется в несколько этапов:

- получение позиционно независимых переносимых объектных файлов:
```
gcc -c file.c -fPIC -o file.o
```
Параметр **-fPIC**, обязателен, при создании динамических библиотек из набора переносимых объектных файлов. 
PIC - Position Independent Code (позиционно независимый код). Позиционная независимость означает, 
что инструкции внутри переносимого объектного файла имеют не фиксированные, а относительные адреса; 
т.о, в разных процессах они могут находиться на разных участках памяти.

- создание динамической библиотеки из набора переносимых объектных файлов, скомпилированных с параметром -fPIC:
```
gcc -shared [file.o ... file.o] -o libName.so
```
- компоновка с разделяемой библиотекой:
```
gcc main.o -L/path-to-shared -lname -lm -o main.out
```
- обновить переменную среды **LD_LIBRARY_PATH** так, чтобы она указывала на текущий каталог.
```
export LD_LIBRARY_PATH=/path-to-shared-object
```

**ВАЖНОЕ ЗАМЕЧАНИЕ:**
- если по указанному пути будут находиться две библиотеки **.a** и **.so**, компилятор сделает выбор в 
пользу разделяемой библиотеки;
- статическая библиотека встраивается с испольняемый файл, в то время как разделяемая библиотека загружается 
в в него в момент выполнения.

#### Ручная (отложенная) загрузка разделяемых библиотек

Для этого используются функции **dlopen** и **dlsym**, чтобы загрузить разделяемый объектный файл и выполнить 
в нем поиск символа. 

Это может понадобиться когда у есть разные реализации или версии одной и той же библиотеки. 
Гибкость отложенной загрузки позволяет выбрать нужные разделяемые объектные файлы, исходя из логики программы,
и сделать это в подходящий момент. 
Для сравнения: традиционный способ подразумевает автоматическую разгрузку во время запуска программы, 
что дает меньше контроля за происходящим.

