#### СОДЕРЖАНИЕ

```
src-0 - пример создания дочернего процесса;
src-1 - пример вывода в стандарьный поток родительского и дочернего процессов;
src-2 - пример использования разделяемой памяти;
src-3 - пример чтения объекта разделяемой памяти, созданного в src-2;
src-4 - пример гонки данных с использованием разделяемой памяти.
```

#### Создание процесса

Чтобы создать новый дочерний процесс, родительскому процессу необходимо вызвать функцию **fork**.

При вызове функции **fork** создается точная копия вызывающего (родительского) процесса. 
В результате оба процесса продолжают работать конкурентно, начиная с инструкции, которая идет за вызовом **fork**. 
Дочерний процесс наследует много атрибутов от своего родителя, включая все сегменты памяти и их содержимое. 
Следовательно, он имеет доступ ко всем тем же переменным в сегментах данных и кучи, а также содержит те же 
программные инструкции в сегменте кода.

Поскольку мы получаем два разных процесса, функция **fork** возвращается дважды:
в родительском процессе и в дочернем. Кроме того, в каждом процессе fork возвращает разные значения: 
ноль в дочернем и PID нового процесса в родительском.

Дочерний процесс наследует от родителя те же файловый дескриптор **stdout** и терминал. 
Следовательно, может возвращать данные в тот же вывод, что и родитель. Потомок наследует файловые дескрипторы, открытые на
момент вызова функции **fork** в родительском процессе.

**Примечание:**
Утилита **pstree** выводит древовидный список всех процессов в системе.

В Linux самым первым процессом является планировщик, который входит в образ ядра и имеет PID 0. 
Следующий процесс обычно называется **init**, и его PID равен 1; это первый процесс, который создается планировщиком. 
Он существует с момента запуска системы и до ее выключения. Все остальные пользовательские процессы —
прямые или непрямые потомки **init**. Процесс, потерявший родителя, становится **сиротой**, и **init** делает его своим прямым потомком.

Однако в более новых версиях почти всех известных дистрибутивов Linux процесс init был заменен демоном **systemd**.

#### Выполнение процесса

Один из способов выполнить новый процесс заключается в использовании функций семейства **exec.**
Философию, стоящую за функциями **exec**, можно описать так: вначале создается простой базовый процесс, 
и затем в какой-то момент в него загружается нужный нам исполняемый файл, который становится новым образом процесса.

Функции **exec** могут запускать разного рода исполняемые файлы.
Ниже перечислены все файловые форматы, которые поддерживаются этими функциями:
- исполняемые файлы ELF;
- скриптовые файлы с символами #! в самом начале, которые обозначают интерпретатор скрипта;
- традиционный формат двоичных файлов a.out;
- исполняемые файлы ELF FDPIC.

#### Этапы выполнения процесса

Когда пользовательское пространство инициирует системный вызов **exec**, ядро получает новый запрос на запуск исполняемого файла. 
Оно пытается найти подходящий обработчик для файлов этого типа и затем использует загрузчик, чтобы загрузить содержимое исполняемого файла.

Обратите внимание: в случае со скриптом загружается программа-интерпретатор, которая обычно указывается в первой строчке скрипта 
вслед за символами **#!**.

Чтобы выполнить процесс, загрузчик обязан произвести следующие действия:
- проверить контекст выполнения и права доступа пользователя, который запросил выполнение;
- выделить для нового процесса адресное пространство в основной памяти;
- скопировать двоичное содержимое исполняемого файла в выделенное пространство. Это в основном касается сегментов данных и кода;
- выделить область памяти для сегмента стека и подготовить начальные привязки памяти;
- создать главный поток выполнения и его сегмент стека;
- скопировать аргументы командной строки в стековый фрейм и поместить его на вершину стека главного потока;
- инициализировать регистры, необходимые для выполнения;
- выполнить первую инструкцию точки входа в программу.

#### Методы разделения ресурсов

Существует два основных метода (у каждого из них есть подкатегории):
- состояние зранимое где-либо (активные);
- отправка сообщения (пассивные).

Ниже перечислены активные методики, которые поддерживаются в стандарте POSIX:
- разделяемая память;
- файловая система;
- сетевые сервисы.

#### Разделяемая память в POSIX

Разделяемая память поддерживается стандартом POSIX и является одним из самых распространенных методов разделения информации 
между разными процессами. Процессы, в отличие от потоков, не имеют доступа к общему пространствупамяти; он запрещен на 
уровне операционной системы. Следовательно, нам нужен какой-то механизм, который позволит разделять участки памяти между двумя 
процессами, и разделяемая память — именно такой механизм.

**Примечание:**

В Linux объекты разделяемой памяти доступны в каталоге **/dev/shm**. 
Для **/dev/shm** используется файловая система **shmfs**. Она доступна только в Linux и предназначена для предоставления доступа к временным
объектам внутри памяти через подключенный каталог.

Объект разделяемой памяти **/shm0** остается на месте даже после завершения программы. Будущие процессы могут снова его открыть и 
прочитать. Объект разделяемой памяти уничтожается либо во время перезагрузки системы, либо самим процессом.

Чтобы итоговому исполняемому файлу в Linux были доступны механизмы работы с разделяемой памятью, его необходимо скомпоновать 
с библиотекой **rt**. Для этого необходим указать параметр **-lrt** в **makefile**.

Когда открывается какой-либо файл, в каждом процессе для него создается новый дескриптор. Данный файл может находиться не на диске; 
это может быть объект разделяемой памяти, стандартный вывод и т.д. В каждом процессе файловые дескрипторы начинаются с 0 и инкрементируются, 
пока не достигнут максимально разрешенного числа.
Следует отметить, что в каждом процессе номера файловых дескрипторов 0, 1 и 2 заранее назначены потокам данных stdin, stdiout и stderr 
соответственно. 
Эти дескрипторы открываются для каждого нового процесса перед началом выполнения функции **main**. Вот почему в нашем примере объект 
разделяемой памяти получает файловый дескриптор 3.

**ВАЖНО:** Объект разделяемой памяти не может пережить перезагрузку, и процессам, которые хотят взаимодействовать, 
приходится создавать его заново.
Oбъект разделяемой памяти существует, пока им пользуется хотя бы один процесс.




